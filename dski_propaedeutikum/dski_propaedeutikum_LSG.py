#tw, 15.3.2023
#-------------

#                          =======================================================
#                          =======================================================
#                                    DSKI-PROPÄDEUTIKUM - Lösungen zu den Aufgaben
#                          =======================================================
#                          =======================================================
#
#
#   






#########################################################################################
#########################################################################################
#########################################################################################
#########################################################################################
#########################################################################################





#                                    2 - Python-Tricks
#                                    =================


#########################################################################################
#########################################################################################
# 2-1 Using List Comprehension to Find Top Earners
#########################################################################################







#########################################################################################
#########################################################################################
# 2-2 Using List Comprehension to Find Words with High Information Value
#########################################################################################







#########################################################################################
#########################################################################################
# 2-3 Reading a File
#########################################################################################







#########################################################################################
#########################################################################################
# 2-4 Using Lambda and Map Functions
#########################################################################################




#~~~~~~~~
#Aufgabe:
#~~~~~~~~
#Verwenden Sie eine list comprehension anstelle der Funktion map(), 
#um das gleiche Ergebnis zu erzielen. 
#~~~~~~~~
txt = ['lambda functions are anonymous functions.',
       'anonymous functions dont have a name.',
       'functions are objects in Python.']
#Lsg.:
[(True,s) if 'anonymous' in s else (False,s) for s in txt]
#ergibt: [(True, 'lambda functions are anonymous functions.'),
#         (True, 'anonymous functions dont have a name.'),
#         (False, 'functions are objects in Python.')]





#########################################################################################
#########################################################################################
# 2-5 Using Slicing to Extract Matching Substring Environments
#########################################################################################







#########################################################################################
#########################################################################################
# 2-6 Combining List Comprehension and Slicing
#########################################################################################







#########################################################################################
#########################################################################################
# 2-7 Using Slice Assignment to Correct Corrupted Lists
#########################################################################################







#########################################################################################
#########################################################################################
# 2-8 Analyzing Cardiac Health Data with List Concatenation
#########################################################################################







#########################################################################################
#########################################################################################
# 2-9 Using Generator Expressions to Find Companies That Pay Below Minimum Wage
#########################################################################################







#########################################################################################
#########################################################################################
# 2-10 Formatting Databases with the zip() Function
#########################################################################################







#########################################################################################
#########################################################################################
#########################################################################################
#########################################################################################
#########################################################################################





#                                    3 - Data Science mit numpy
#                                    ==========================



#########################################################################################
#########################################################################################
# 3-1 Basic Two-Dimensional Array Arithmetic
#########################################################################################







#########################################################################################
#########################################################################################
# 3-2 Working with NumPy Arrays: Slicing, Broadcasting, and Array Types
#########################################################################################







#########################################################################################
#########################################################################################
# 3-3 Conditional Array Search, Filtering, and Broadcasting to Detect Outliers
#########################################################################################




#~~~~~~~~
#Aufgabe:
#~~~~~~~~
#Gehen Sie zurück zum Kap 3-1 "Basic Two-Dimensional Array Arithmetic" und ziehen Sie den 
#Namen der Person mit dem höchsten Gehalt aus der Matrix heraus, indem Sie die Idee der 
#selektiven booleschen Indizierung (boolesche Array-Operationen in Verbindung mit Broadcasting) 
#anwenden, die sie hier im Kap 3-3 kennengelernt haben. 
#Rekapitulieren Sie das Problem: Wie findet man die Person mit dem höchsten Einkommen nach 
#Steuern in einer Gruppe von Personen unter Berücksichtigung ihres Jahresgehalts und ihrer 
#Steuersätze?
#~~~~~~~~
#Lsg.:
import numpy as np
alice = [99, 101, 103]
bob = [110, 108, 105]
tim = [90, 88, 85]
salaries = np.array([alice, bob, tim])
names = np.array(["Alice", "Bob", "Tim"])      # <--- neu
taxation = np.array([[0.2, 0.25, 0.22],
                     [0.4, 0.5, 0.5],
                     [0.1, 0.2, 0.1]])
taxed_salaries = salaries - salaries * taxation
print(taxed_salaries)     #[[79.2  75.75 80.34]
                          # [66.   54.   52.5 ]
                          # [81.   70.4  76.5 ]]
max_taxed_income = np.max(taxed_salaries)
print(max_taxed_income)     #81.0
print(names[np.nonzero(taxed_salaries == max_taxed_income)[0]])   #['Tim']



#~~~~~~~~
#Aufgabe:
#~~~~~~~~
#Sehen Sie sich Kap 2-6 "Combining List Comprehension and Slicing" noch einmal an und 
#entwerfen Sie eine prägnantere Einzeiler-Lösung unter Verwendung der NumPy-Bibliothek. 
#Tipp: Verwenden Sie NumPy's leistungsfähigere Slicing-Fähigkeiten.
#~~~~~~~~
#Lsg.:
#Erstmal brauchen wir die Daten aus Kap 2-6:
#Wir wollen nur jedes zweite Element von price behalten...
price = [[9.9, 9.8, 9.8, 9.4, 9.5, 9.7],
         [9.5, 9.4, 9.4, 9.3, 9.2, 9.1],
         [8.4, 7.9, 7.9, 8.1, 8.0, 8.0],
         [7.1, 5.9, 4.8, 4.8, 4.7, 3.9]]
sample = [line[::2] for line in price]
print(sample)    #[[9.9, 9.8, 9.5], [9.5, 9.4, 9.2], [8.4, 7.9, 8.0], [7.1, 4.8, 4.7]]
#Wie kann man das mit Numpy-Techniken noch kürzer formulieren ?
#Wir erzeugen aus der Standard-Liste-von-Listen price ein 2-D Numpy-Array price_np:
price_np = np.array(price)
#Nun können wir die erweiterten Indizierungsmöglichkeiten von Numpy verwenden:
price_np[:, ::2]     #array([[9.9, 9.8, 9.5],
                     #       [9.5, 9.4, 9.2],
                     #       [8.4, 7.9, 8. ],
                     #       [7.1, 4.8, 4.7]])





#########################################################################################
#########################################################################################
# 3-4 Boolean Indexing to Filter Two-Dimensional Arrays
#########################################################################################






#########################################################################################
#########################################################################################
# 3-5 Broadcasting, Slice Assignment, and Reshaping to Clean Every i-th Array Element
#########################################################################################







#########################################################################################
#########################################################################################
# 3-6 When to Use the sort() Function and When to Use the argsort() Function in NumPy
#########################################################################################







#########################################################################################
#########################################################################################
# 3-7 How to Use Lambda Functions and Boolean Indexing to Filter Arrays
#########################################################################################







#########################################################################################
#########################################################################################
# 3-8 How to Create Advanced Array Filters with Statistics, Math, and Logic
#########################################################################################







#########################################################################################
#########################################################################################
# 3-9 Simple Association Analysis: People Who Bought X Also Bought Y
#########################################################################################







#########################################################################################
# 3-10 Intermediate Association Analysis to Find Bestseller Bundles
#########################################################################################



   



#########################################################################################
#########################################################################################
#########################################################################################
#########################################################################################
#########################################################################################





#                                    4 - Machine Learning mit scikit-learn
#                                    =====================================





#########################################################################################
#########################################################################################
# 4.1 Linear Regression
#########################################################################################







#########################################################################################

#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#FINIS














